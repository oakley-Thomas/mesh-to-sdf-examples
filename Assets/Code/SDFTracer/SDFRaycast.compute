#pragma kernel CSMain

StructuredBuffer<float3> _Directions;
RWStructuredBuffer<float4> _Intersections;

float4x4 _WorldToSDFSpace;
Texture3D<float> _SDF;
SamplerState sampler_SDF;
float _Margin;
int _MaxIterations;
float _MaxDistance;
float _HitThreshold;

float SampleSDF(float3 sdfPos)
{
    return _SDF.SampleLevel(sampler_SDF, sdfPos, 0).r - _Margin;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint count, stride;
    _Directions.GetDimensions(count, stride);
    if (id.x >= count)
        return;

    float3 dirWorld = normalize(_Directions[id.x]);

    // Transform direction into SDF space
    float3 dirSDFTrans = mul((float3x3)_WorldToSDFSpace, dirWorld);
    float dirScale = length(dirSDFTrans);
    float3 dirSDF = dirSDFTrans / dirScale;

    // Starting position of the ray in SDF space
    float3 pos = mul(_WorldToSDFSpace, float4(0.0, 0.0, 0.0, 1.0)).xyz;

    // Convert maximum distance to SDF space
    float maxDistance = _MaxDistance * dirScale;

    float t = 0.0;
    float hit = 0.0;

    for (uint i = 0; i < (uint)_MaxIterations && t < maxDistance; ++i)
    {
        float distWorld = SampleSDF(pos);
        if (distWorld < _HitThreshold)
        {
            hit = 1.0;
            break;
        }

        float distSDF = distWorld * dirScale;
        t += distSDF;
        pos += dirSDF * distSDF;
    }

    float worldT = t / dirScale;
    float3 worldPos = dirWorld * worldT;

    _Intersections[id.x] = float4(worldPos, hit);
}

